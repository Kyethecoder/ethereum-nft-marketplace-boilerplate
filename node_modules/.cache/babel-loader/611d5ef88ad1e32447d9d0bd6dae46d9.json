{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { ContactsOutlined } from \"@ant-design/icons\";\nimport { useMoralisDapp } from \"providers/MoralisDappProvider/MoralisDappProvider\";\nimport { useEffect, useState } from \"react\";\nimport { useMoralisWeb3Api, useMoralisWeb3ApiCall } from \"react-moralis\";\nimport { useIPFS } from \"./useIPFS\";\nexport const useNFTTokenIds = addr => {\n  _s();\n\n  const {\n    token\n  } = useMoralisWeb3Api();\n  const {\n    chainId\n  } = useMoralisDapp();\n  const {\n    resolveLink\n  } = useIPFS();\n  const [NFTTokenIds, setNFTTokenIds] = useState([]);\n  const [totalNFTs, setTotalNFTs] = useState();\n  const [fetchSuccess, setFetchSuccess] = useState(true);\n  const {\n    fetch: getNFTTokenIds,\n    data,\n    error,\n    isLoading\n  } = useMoralisWeb3ApiCall(token.getAllTokenIds, {\n    chain: chainId,\n    address: addr,\n    limit: 10\n  });\n  useEffect(async () => {\n    if (data === null || data === void 0 ? void 0 : data.result) {\n      const NFTs = data.result;\n      setTotalNFTs(data.total);\n      setFetchSuccess(true);\n\n      for (let NFT of NFTs) {\n        if (NFT === null || NFT === void 0 ? void 0 : NFT.metadata) {\n          var _NFT$metadata;\n\n          NFT.metadata = JSON.parse(NFT.metadata);\n          NFT.image = resolveLink((_NFT$metadata = NFT.metadata) === null || _NFT$metadata === void 0 ? void 0 : _NFT$metadata.image);\n        } else if (NFT === null || NFT === void 0 ? void 0 : NFT.token_uri) {\n          try {\n            await fetch(NFT.token_uri).then(response => response.json()).then(data => {\n              NFT.image = resolveLink(data.image);\n            });\n          } catch (error) {\n            setFetchSuccess(false);\n            /*          !!Temporary work around to avoid CORS issues when retrieving NFT images!!\r\n                        Create a proxy server as per https://dev.to/terieyenike/how-to-create-a-proxy-server-on-heroku-5b5c\r\n                        Replace <your url here> with your proxy server_url below\r\n                        Remove comments :)\r\n            \r\n                          try {\r\n                            await fetch(`<your url here>/${NFT.token_uri}`)\r\n                            .then(response => response.json())\r\n                            .then(data => {\r\n                              NFT.image = resolveLink(data.image);\r\n                            });\r\n                          } catch (error) {\r\n                            setFetchSuccess(false);\r\n                          }\r\n            \r\n             */\n          }\n        }\n      }\n\n      setNFTTokenIds(NFTs);\n    }\n  }, [data]);\n  return {\n    getNFTTokenIds,\n    NFTTokenIds,\n    totalNFTs,\n    fetchSuccess,\n    error,\n    isLoading\n  };\n};\n\n_s(useNFTTokenIds, \"EZuAvYHJrXxMpEYgFy2Vx8IaAV0=\", false, function () {\n  return [useMoralisWeb3Api, useMoralisDapp, useIPFS, useMoralisWeb3ApiCall];\n});","map":{"version":3,"sources":["C:/Users/Kye Goullet/Documents/opensea Dapp/ethereum-nft-marketplace-boilerplate/src/hooks/useNFTTokenIds.js"],"names":["ContactsOutlined","useMoralisDapp","useEffect","useState","useMoralisWeb3Api","useMoralisWeb3ApiCall","useIPFS","useNFTTokenIds","addr","token","chainId","resolveLink","NFTTokenIds","setNFTTokenIds","totalNFTs","setTotalNFTs","fetchSuccess","setFetchSuccess","fetch","getNFTTokenIds","data","error","isLoading","getAllTokenIds","chain","address","limit","result","NFTs","total","NFT","metadata","JSON","parse","image","token_uri","then","response","json"],"mappings":";;AAAA,SAASA,gBAAT,QAAiC,mBAAjC;AACA,SAASC,cAAT,QAA+B,mDAA/B;AACA,SAASC,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA,SAASC,iBAAT,EAA4BC,qBAA5B,QAAyD,eAAzD;AACA,SAASC,OAAT,QAAwB,WAAxB;AAEA,OAAO,MAAMC,cAAc,GAAIC,IAAD,IAAU;AAAA;;AACtC,QAAM;AAAEC,IAAAA;AAAF,MAAYL,iBAAiB,EAAnC;AACA,QAAM;AAAEM,IAAAA;AAAF,MAAcT,cAAc,EAAlC;AACA,QAAM;AAAEU,IAAAA;AAAF,MAAkBL,OAAO,EAA/B;AACA,QAAM,CAACM,WAAD,EAAcC,cAAd,IAAgCV,QAAQ,CAAC,EAAD,CAA9C;AACA,QAAM,CAACW,SAAD,EAAYC,YAAZ,IAA4BZ,QAAQ,EAA1C;AACA,QAAM,CAACa,YAAD,EAAeC,eAAf,IAAkCd,QAAQ,CAAC,IAAD,CAAhD;AACA,QAAM;AACJe,IAAAA,KAAK,EAAEC,cADH;AAEJC,IAAAA,IAFI;AAGJC,IAAAA,KAHI;AAIJC,IAAAA;AAJI,MAKFjB,qBAAqB,CAACI,KAAK,CAACc,cAAP,EAAuB;AAC9CC,IAAAA,KAAK,EAAEd,OADuC;AAE9Ce,IAAAA,OAAO,EAAEjB,IAFqC;AAG9CkB,IAAAA,KAAK,EAAE;AAHuC,GAAvB,CALzB;AAWAxB,EAAAA,SAAS,CAAC,YAAY;AACpB,QAAIkB,IAAJ,aAAIA,IAAJ,uBAAIA,IAAI,CAAEO,MAAV,EAAkB;AAChB,YAAMC,IAAI,GAAGR,IAAI,CAACO,MAAlB;AACAZ,MAAAA,YAAY,CAACK,IAAI,CAACS,KAAN,CAAZ;AACAZ,MAAAA,eAAe,CAAC,IAAD,CAAf;;AACA,WAAK,IAAIa,GAAT,IAAgBF,IAAhB,EAAsB;AACpB,YAAIE,GAAJ,aAAIA,GAAJ,uBAAIA,GAAG,CAAEC,QAAT,EAAmB;AAAA;;AACjBD,UAAAA,GAAG,CAACC,QAAJ,GAAeC,IAAI,CAACC,KAAL,CAAWH,GAAG,CAACC,QAAf,CAAf;AACAD,UAAAA,GAAG,CAACI,KAAJ,GAAYvB,WAAW,kBAACmB,GAAG,CAACC,QAAL,kDAAC,cAAcG,KAAf,CAAvB;AACD,SAHD,MAGO,IAAIJ,GAAJ,aAAIA,GAAJ,uBAAIA,GAAG,CAAEK,SAAT,EAAoB;AACzB,cAAI;AACF,kBAAMjB,KAAK,CAACY,GAAG,CAACK,SAAL,CAAL,CACHC,IADG,CACGC,QAAD,IAAcA,QAAQ,CAACC,IAAT,EADhB,EAEHF,IAFG,CAEGhB,IAAD,IAAU;AACdU,cAAAA,GAAG,CAACI,KAAJ,GAAYvB,WAAW,CAACS,IAAI,CAACc,KAAN,CAAvB;AACD,aAJG,CAAN;AAKD,WAND,CAME,OAAOb,KAAP,EAAc;AACdJ,YAAAA,eAAe,CAAC,KAAD,CAAf;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACW;AACF;AACF;;AACDJ,MAAAA,cAAc,CAACe,IAAD,CAAd;AACD;AACF,GAxCQ,EAwCN,CAACR,IAAD,CAxCM,CAAT;AA0CA,SAAO;AACLD,IAAAA,cADK;AAELP,IAAAA,WAFK;AAGLE,IAAAA,SAHK;AAILE,IAAAA,YAJK;AAKLK,IAAAA,KALK;AAMLC,IAAAA;AANK,GAAP;AAQD,CApEM;;GAAMf,c;UACOH,iB,EACEH,c,EACIK,O,EASpBD,qB","sourcesContent":["import { ContactsOutlined } from \"@ant-design/icons\";\r\nimport { useMoralisDapp } from \"providers/MoralisDappProvider/MoralisDappProvider\";\r\nimport { useEffect, useState } from \"react\";\r\nimport { useMoralisWeb3Api, useMoralisWeb3ApiCall } from \"react-moralis\";\r\nimport { useIPFS } from \"./useIPFS\";\r\n\r\nexport const useNFTTokenIds = (addr) => {\r\n  const { token } = useMoralisWeb3Api();\r\n  const { chainId } = useMoralisDapp();\r\n  const { resolveLink } = useIPFS();\r\n  const [NFTTokenIds, setNFTTokenIds] = useState([]);\r\n  const [totalNFTs, setTotalNFTs] = useState();\r\n  const [fetchSuccess, setFetchSuccess] = useState(true);\r\n  const {\r\n    fetch: getNFTTokenIds,\r\n    data,\r\n    error,\r\n    isLoading,\r\n  } = useMoralisWeb3ApiCall(token.getAllTokenIds, {\r\n    chain: chainId,\r\n    address: addr,\r\n    limit: 10,\r\n  });\r\n\r\n  useEffect(async () => {\r\n    if (data?.result) {\r\n      const NFTs = data.result;\r\n      setTotalNFTs(data.total);\r\n      setFetchSuccess(true);\r\n      for (let NFT of NFTs) {\r\n        if (NFT?.metadata) {\r\n          NFT.metadata = JSON.parse(NFT.metadata);\r\n          NFT.image = resolveLink(NFT.metadata?.image);\r\n        } else if (NFT?.token_uri) {\r\n          try {\r\n            await fetch(NFT.token_uri)\r\n              .then((response) => response.json())\r\n              .then((data) => {\r\n                NFT.image = resolveLink(data.image);\r\n              });\r\n          } catch (error) {\r\n            setFetchSuccess(false);\r\n              \r\n/*          !!Temporary work around to avoid CORS issues when retrieving NFT images!!\r\n            Create a proxy server as per https://dev.to/terieyenike/how-to-create-a-proxy-server-on-heroku-5b5c\r\n            Replace <your url here> with your proxy server_url below\r\n            Remove comments :)\r\n\r\n              try {\r\n                await fetch(`<your url here>/${NFT.token_uri}`)\r\n                .then(response => response.json())\r\n                .then(data => {\r\n                  NFT.image = resolveLink(data.image);\r\n                });\r\n              } catch (error) {\r\n                setFetchSuccess(false);\r\n              }\r\n\r\n */\r\n          }\r\n        }\r\n      }\r\n      setNFTTokenIds(NFTs);\r\n    }\r\n  }, [data]);\r\n\r\n  return {\r\n    getNFTTokenIds,\r\n    NFTTokenIds,\r\n    totalNFTs,\r\n    fetchSuccess,\r\n    error,\r\n    isLoading,\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}